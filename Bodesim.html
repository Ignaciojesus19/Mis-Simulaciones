<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Avanzado de Bode</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 0; padding: 0; background: #f4f4f9; color: #333; display: flex; flex-direction: column; height: 100vh; }
        header { background: #2c3e50; color: white; padding: 1rem; text-align: center; }
        .container { display: flex; flex: 1; overflow: hidden; }
        
        /* Panel de Control y Fórmulas */
        .sidebar { width: 350px; background: white; padding: 20px; overflow-y: auto; border-right: 1px solid #ddd; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        .input-group { margin-bottom: 20px; }
        label { font-weight: bold; display: block; margin-bottom: 5px; }
        input[type="text"] { width: 95%; padding: 10px; font-size: 16px; border: 2px solid #3498db; border-radius: 4px; font-family: 'Courier New', monospace; }
        button { background: #3498db; color: white; border: none; padding: 10px 20px; cursor: pointer; font-size: 16px; border-radius: 4px; width: 100%; margin-top: 10px; transition: 0.3s; }
        button:hover { background: #2980b9; }
        
        .results-box { background: #e8f6f3; border-left: 5px solid #1abc9c; padding: 10px; margin-top: 20px; }
        .formula-box { background: #fdfefe; border: 1px solid #eee; padding: 10px; margin-top: 20px; font-size: 0.9em; }
        
        /* Área de Gráficos */
        .main-content { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; }
        .plot-container { background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); padding: 10px; height: 45%; }
        
        h3 { color: #2c3e50; border-bottom: 2px solid #ecf0f1; padding-bottom: 5px; }
        .error-msg { color: #e74c3c; font-weight: bold; margin-top: 10px; display: none; }
    </style>
</head>
<body>

<header>
    <h2>Simulador Interactivo: Diagrama de Bode</h2>
</header>

<div class="container">
    <div class="sidebar">
        <div class="input-group">
            <label for="tfInput">Función de Transferencia \( H(s) \):</label>
            <input type="text" id="tfInput" value="100 / (s^2 + 10*s + 100)" placeholder="Ej: 1 / (s + 1)">
            <small style="color: #7f8c8d;">Usa 's' como variable. Ej: <code>10/(s*(s+2))</code></small>
            <button onclick="calculateBode()">Actualizar Gráficos</button>
            <div id="errorDisplay" class="error-msg"></div>
        </div>

        <div class="results-box">
            <h3>Márgenes de Estabilidad</h3>
            <p><strong>Margen de Ganancia (GM):</strong> <span id="gmValue">--</span> dB</p>
            <p>Frec. de Cruce de Fase (\(\omega_{pc}\)): <span id="wpcValue">--</span> rad/s</p>
            <hr>
            <p><strong>Margen de Fase (PM):</strong> <span id="pmValue">--</span> deg</p>
            <p>Frec. de Cruce de Ganancia (\(\omega_{gc}\)): <span id="wgcValue">--</span> rad/s</p>
            <p id="stabilityVerdict" style="font-weight: bold; margin-top:10px;"></p>
        </div>

        <div class="formula-box">
            <h3>Fórmulas Teóricas</h3>
            <p>Sea \( s = j\omega \):</p>
            <p><strong>Magnitud (dB):</strong></p>
            $$ M_{dB} = 20 \log_{10} |H(j\omega)| $$
            
            <p><strong>Fase (grados):</strong></p>
            $$ \phi = \angle H(j\omega) = \tan^{-1}\left(\frac{Im}{Re}\right) $$
            
            <p><strong>Criterios:</strong></p>
            <ul>
                <li>\(\omega_{gc}\): Frecuencia donde \( |H| = 1 \) (0 dB).</li>
                <li>\(\omega_{pc}\): Frecuencia donde \( \phi = -180^\circ \).</li>
                <li><strong>PM:</strong> \( 180^\circ + \phi(\omega_{gc}) \)</li>
                <li><strong>GM:</strong> \( 0 - M_{dB}(\omega_{pc}) \)</li>
            </ul>
        </div>
    </div>

    <div class="main-content">
        <div id="magPlot" class="plot-container"></div>
        <div id="phasePlot" class="plot-container"></div>
    </div>
</div>

<script>
    // Configuración Inicial
    const w_start = 0.1;
    const w_end = 1000;
    const points = 500;

    function generateLogSpace(start, end, num) {
        const logStart = Math.log10(start);
        const logEnd = Math.log10(end);
        const step = (logEnd - logStart) / (num - 1);
        return Array.from({length: num}, (_, i) => Math.pow(10, logStart + (i * step)));
    }

    function calculateBode() {
        const exprStr = document.getElementById('tfInput').value;
        const errorDiv = document.getElementById('errorDisplay');
        const gmSpan = document.getElementById('gmValue');
        const pmSpan = document.getElementById('pmValue');
        const wpcSpan = document.getElementById('wpcValue');
        const wgcSpan = document.getElementById('wgcValue');
        const verdict = document.getElementById('stabilityVerdict');

        errorDiv.style.display = 'none';

        try {
            const compiledExpr = math.compile(exprStr);
            const freqs = generateLogSpace(w_start, w_end, points);
            
            const magnitudes = [];
            const phases = [];
            const magDBs = [];
            
            // Arrays para detección de cruces
            let pm = null; // Phase Margin
            let gm = null; // Gain Margin
            let w_gc = null; // Gain Crossover Freq
            let w_pc = null; // Phase Crossover Freq

            // Cálculo de datos
            freqs.forEach(w => {
                // Evaluar H(jw)
                const sVal = math.complex(0, w);
                const result = compiledExpr.evaluate({ s: sVal });
                
                // Magnitud
                const mag = result.abs();
                const db = 20 * Math.log10(mag);
                magnitudes.push(mag);
                magDBs.push(db);

                // Fase (Unwrapped logic simplificada para visualización básica)
                let phase = result.arg() * (180 / Math.PI); 
                // Ajustar a rango -270 a 90 para visualización típica de control
                // Nota: Un unwrapping real completo requiere historial, aquí usamos math.js standard
                phases.push(phase);
            });

            // --- Algoritmo simple para encontrar márgenes ---
            // 1. Encontrar Wgc (donde magDB cruza 0)
            for (let i = 0; i < magDBs.length - 1; i++) {
                if ((magDBs[i] >= 0 && magDBs[i+1] < 0) || (magDBs[i] <= 0 && magDBs[i+1] > 0)) {
                    w_gc = freqs[i]; // Aprox
                    // Calcular Fase en Wgc
                    const phaseAtWgc = phases[i];
                    pm = 180 + phaseAtWgc; 
                    break; 
                }
            }

            // 2. Encontrar Wpc (donde phase cruza -180)
            for (let i = 0; i < phases.length - 1; i++) {
                // Detectar cruce por -180 (asumiendo continuidad)
                if ((phases[i] >= -180 && phases[i+1] < -180)) {
                    w_pc = freqs[i];
                    // Calcular Ganancia en Wpc
                    const dbAtWpc = magDBs[i];
                    gm = 0 - dbAtWpc;
                    break;
                }
            }

            // Actualizar UI de márgenes
            wgcSpan.innerText = w_gc ? w_gc.toFixed(2) : "N/A";
            pmSpan.innerText = pm ? pm.toFixed(2) : "Inf";
            wpcSpan.innerText = w_pc ? wpc.toFixed(2) : "N/A";
            gmSpan.innerText = gm ? gm.toFixed(2) : "Inf";

            if (pm > 0 && gm > 0) {
                verdict.innerText = "Sistema Estable";
                verdict.style.color = "green";
            } else if (pm !== null || gm !== null) {
                verdict.innerText = "Posible Inestabilidad";
                verdict.style.color = "red";
            } else {
                verdict.innerText = "Indeterminado / Margen Infinito";
                verdict.style.color = "orange";
            }

            // --- Gráfico de Magnitud ---
            const traceMag = {
                x: freqs,
                y: magDBs,
                type: 'scatter',
                mode: 'lines',
                name: 'Magnitud (dB)',
                line: { color: '#2980b9', width: 3 },
                hovertemplate: 'Frec: %{x:.2f} rad/s<br>Mag: %{y:.2f} dB<extra></extra>'
            };

            const layoutMag = {
                title: 'Diagrama de Bode - Magnitud',
                xaxis: { type: 'log', title: 'Frecuencia (rad/s)', gridcolor: '#eee' },
                yaxis: { title: 'Magnitud (dB)', gridcolor: '#eee' },
                margin: { t: 40, r: 20, b: 40, l: 60 },
                shapes: [
                    { type: 'line', y0: 0, y1: 0, x0: w_start, x1: w_end, line: {color: 'red', width: 1, dash: 'dot'} }
                ]
            };

            // --- Gráfico de Fase ---
            const tracePhase = {
                x: freqs,
                y: phases,
                type: 'scatter',
                mode: 'lines',
                name: 'Fase (deg)',
                line: { color: '#e74c3c', width: 3 },
                hovertemplate: 'Frec: %{x:.2f} rad/s<br>Fase: %{y:.2f}°<extra></extra>'
            };

            const layoutPhase = {
                title: 'Diagrama de Bode - Fase',
                xaxis: { type: 'log', title: 'Frecuencia (rad/s)', gridcolor: '#eee' },
                yaxis: { title: 'Fase (grados)', gridcolor: '#eee' },
                margin: { t: 40, r: 20, b: 40, l: 60 },
                shapes: [
                    { type: 'line', y0: -180, y1: -180, x0: w_start, x1: w_end, line: {color: 'black', width: 1, dash: 'dot'} }
                ]
            };

            Plotly.newPlot('magPlot', [traceMag], layoutMag, {responsive: true});
            Plotly.newPlot('phasePlot', [tracePhase], layoutPhase, {responsive: true});

        } catch (e) {
            errorDiv.innerText = "Error en la función: Verifique paréntesis y operadores. " + e.message;
            errorDiv.style.display = 'block';
        }
    }

    // Inicializar al cargar
    window.onload = calculateBode;
    
    // Permitir Enter para calcular
    document.getElementById("tfInput").addEventListener("keyup", function(event) {
        if (event.key === "Enter") {
            calculateBode();
        }
    });

</script>

</body>
</html>
