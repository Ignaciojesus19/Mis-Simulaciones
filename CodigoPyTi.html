<section>
  <h2>Codigo Newton Rapshon NxN Python</h2>
  <pre><code>
import math

# --- 1. AQUÍ DEFINES TU SISTEMA 4x4 ---
def sistema(x):
    # x[0]=1, x[1]=2, x[2]=3, x[3]=4
    
    # Ec 1: Suma = 10
    eq1 = x[0] + x[1] + x[2] - 3 
    
    # Ec 2: Suma de cuadrados = 30
    eq2 = x[0]**2 + x[1]**2 + x[2]**2 - 5
    
    # Ec 3: x0 * x3 = x1^2 (Producto cruzado)
    eq3 = math.exp(x[0]) - x[1]
    
    # Ec 4: x2^2 - x3 = 5
    # eq4 = x[2]**2 - x[3] - 5
    
    # return [eq1, eq2, eq3, eq4]
    return [eq1, eq2, eq3]

# --- 2. CONFIGURACIÓN INICIAL ---
def get_config():
    # Semilla: Damos valores cercanos pero desordenados
    # para ver como el algoritmo los corrige.
    x_inicial = [0.5, 1.5, 2.5] 
    iteraciones = 10
    return x_inicial, iteraciones

# ==========================================
# NO TOCAR NADA DEBAJO DE ESTA LINEA
# ==========================================

def gauss_solve(A, b):
    n = len(b)
    M = [row[:] for row in A]
    y = b[:]
    for i in range(n):
        if abs(M[i][i]) < 1e-12:
            for k in range(i+1, n):
                if abs(M[k][i]) > 1e-12:
                    M[i], M[k] = M[k], M[i]
                    y[i], y[k] = y[k], y[i]
                    break
        pivot = M[i][i]
        for j in range(i, n):
            M[i][j] /= pivot
        y[i] /= pivot
        for k in range(i+1, n):
            factor = M[k][i]
            for j in range(i, n):
                M[k][j] -= factor * M[i][j]
            y[k] -= factor * y[i]
    x_sol = [0] * n
    for i in range(n-1, -1, -1):
        s = sum(M[i][j] * x_sol[j] for j in range(i+1, n))
        x_sol[i] = y[i] - s
    return x_sol

def jacobiano(x):
    n = len(x)
    h = 1e-5
    J = [[0.0]*n for _ in range(n)]
    f0 = sistema(x)
    
    for j in range(n):
        x_temp = x[:]
        x_temp[j] += h
        f_h = sistema(x_temp)
        for i in range(n):
            J[i][j] = (f_h[i] - f0[i]) / h
    return J, f0

def main():
    print("--- NEWTON RAPHSON 3x3 ---")
    x_curr, num_iter = get_config()
    
    print("Inicio:", x_curr)
    
    for k in range(1, num_iter + 1):
        try:
            J, F = jacobiano(x_curr)
            minus_F = [-val for val in F]
            delta = gauss_solve(J, minus_F)
            
            for i in range(len(x_curr)):
                x_curr[i] += delta[i]
                
            print("It", k, ":", [round(v, 4) for v in x_curr])
            
            if all(abs(d) < 1e-6 for d in delta):
                print("Convergencia alcanzada.")
                break
                
        except Exception as e:
            print("Error:", e)
            break
            
    print("\nRESULTADO FINAL:")
    print(x_curr)

if __name__ == "__main__":
    main()
  </code></pre>

  <h2>Codigo Calculo angulos cerchas</h2>
  <pre><code>
import math

def main():
    print("=== TABLA DE ANGULOS SIMPLE ===")
    
    # --- 1. PEDIR NODOS ---
    nodos = {}
    print("PASO 1: Nodos ('f' para fin)")
    while True:
        nid = input("ID: ")
        if nid == 'f' or nid == 'fin': break
        try:
            vid = int(nid)
            x = float(input(" X: "))
            y = float(input(" Y: "))
            nodos[vid] = (x, y)
        except: print("Error num")
            
    if len(nodos) < 2: return

    # --- 2. PEDIR BARRAS ---
    elementos = []
    print("\nPASO 2: Barras ('f' para fin)")
    print("OJO: Origen -> Destino")
    
    cnt = 1
    while True:
        print("- Barra " + str(cnt))
        ori = input(" De: ")
        if ori == 'f' or ori == 'fin': break
        des = input(" A:  ")
        if des == 'f' or des == 'fin': break
        
        try:
            ori = int(ori)
            des = int(des)
            if ori in nodos and des in nodos:
                elementos.append((ori, des))
                cnt += 1
            else: print("Nodo no existe")
        except: pass

    # --- 3. TABLA FINAL ---
    print("\nELEM | NODOS  | ANGULO")
    print("-" * 24)
    
    num = 1
    for (ori, des) in elementos:
        x1, y1 = nodos[ori]
        x2, y2 = nodos[des]
        
        # Calculo Angulo
        dx = x2 - x1
        dy = y2 - y1
        deg = math.degrees(math.atan2(dy, dx))
        if deg < 0: deg += 360
        
        # Formato Simple
        # str(num)       -> Numero de barra
        # str(ori)->str(des) -> Nodos
        # str(deg)       -> Angulo
        
        s_elem = str(num)
        # Ajuste de espacios manual para que se vea alineado
        if num < 10: s_elem += " "
        
        s_conn = str(ori) + "->" + str(des)
        # Relleno de espacios para la columna nodos (aprox 7 chars)
        espacios = " " * (7 - len(s_conn))
        
        print(" " + s_elem + " | " + s_conn + espacios + "| " + str(round(deg, 2)))
        
        num += 1

main()
  </code></pre>
  
  <h2>Codigo Calculo de matriz rigidez barras</h2>
  <pre><code>
    import ti_system as ti
import math

def ensamblaje_final_completo():
    print("--- ANÁLISIS ESTRUCTURAL PASO A PASO ---")
    
    # DATOS PRECARGADOS (Correctos según tu ejercicio)
    # [Nodo_i, Nodo_j, E, A, L, Angulo]
    datos_barras = [
        [1, 2, 30e6, 10.0, 30.0, 90.0],      # 1: Vertical
        [2, 3, 30e6, 10.0, 20.0, 0.0],       # 2: Horizontal
        [2, 4, 30e6, 12.5, 25.0, 323.13],    # 3: Diag (baja)
        [1, 4, 30e6, 12.5, 25.0, 36.87],     # 4: Diag (sube)
        [4, 3, 30e6, 5.0,  15.0, 270.0]      # 5: Vertical (baja)
    ]
    
    num_nodos = 4
    dim = num_nodos * 2
    KG = [[0.0]*dim for _ in range(dim)]
    
    # Etiquetas generales
    labels_all = ["u1","v1","u2","v2","u3","v3","u4","v4"]

    # --- 1. PROCESO DE ELEMENTOS ---
    for idx, elem in enumerate(datos_barras):
        k_num = idx + 1
        print("\n=== ELEMENTO {} ===".format(k_num))
        
        n_i, n_j, E, A, L, ang = elem
        print("Nodos: {}-{} | Ang: {}".format(int(n_i), int(n_j), ang))
        
        # Indices base 0
        ni = int(n_i) - 1
        nj = int(n_j) - 1
        
        # Calculo Rigidez
        rad = math.radians(ang)
        c = math.cos(rad)
        s = math.sin(rad)
        keq = (A * E) / L
        
        kcc = c*c*keq
        kss = s*s*keq
        kcs = c*s*keq
        
        # Matriz Local 4x4
        # Orden: ui, vi, uj, vj
        k_local = [
            [ kcc,  kcs, -kcc, -kcs],
            [ kcs,  kss, -kcs, -kss],
            [-kcc, -kcs,  kcc,  kcs],
            [-kcs, -kss,  kcs,  kss]
        ]
        
        # MOSTRAR MATRIZ LOCAL
        lbls_loc = ["ui","vi","uj","vj"]
        print("Matriz Local (k{}):".format(k_num))
        for r in range(4):
            txt = "{}: ".format(lbls_loc[r])
            for val in k_local[r]:
                if abs(val) < 1e-4: txt += " 0       "
                else: txt += "{:.2e} ".format(val)
            print(txt)

        # ENSAMBLAJE
        indices = [2*ni, 2*ni+1, 2*nj, 2*nj+1]
        for r in range(4):
            for c_ in range(4):
                KG[indices[r]][indices[c_]] += k_local[r][c_]

    # --- 2. MOSTRAR GLOBAL COMPLETA ---
    print("\n" + "="*30)
    print(" MATRIZ GLOBAL COMPLETA (KG) ")
    print("="*30)
    
    # Imprimir encabezado
    head = "   "
    for l in labels_all: head += "{:>9} ".format(l)
    print(head)
    
    for i, row in enumerate(KG):
        txt = "{}: ".format(labels_all[i])
        for val in row:
            if abs(val) < 1.0: # Tolerancia para ceros
                txt += "{:>9} ".format("0")
            else:
                # Mostramos en notacion cientifica corta para que quepa
                txt += "{:>9.2e} ".format(val)
        print(txt)

    # --- 3. REDUCCION ---
    print("\n" + "="*30)
    print("       REDUCCION       ")
    print("="*30)
    print("Indices: 0=u1, 1=v1, 2=u2, 3=v2...")
    
    try:
        # Pide indices (recuerda: 0,1,2,4,6 para tu ejercicio)
        elim_str = input("Indices a eliminar (Ej: 0,1...): ")
        elim_list = [int(x) for x in elim_str.split(",")]
        
        K_RED = []
        lbls_red = []
        
        for i in range(dim):
            if i in elim_list: continue
            
            row_red = []
            for j in range(dim):
                if j in elim_list: continue
                row_red.append(KG[i][j])
            
            K_RED.append(row_red)
            lbls_red.append(labels_all[i])
            
        # MOSTRAR REDUCIDA
        print("\n--- MATRIZ REDUCIDA FINAL ---")
        # Encabezado
        h_red = "      "
        for l in lbls_red: h_red += "{:>10} ".format(l)
        print(h_red)

        for i, row in enumerate(K_RED):
            txt = "{:>4}: ".format(lbls_red[i])
            for val in row:
                # Escalado visual para comparar con tu hoja (div 10^6)
                val_sc = val / 1.0e6
                if abs(val_sc) < 0.0001: txt += "{:>10} ".format("0")
                else: txt += "{:>10.4f} ".format(val_sc)
            print(txt)
        print("(Valores x 10^6)")
        
        # Guardar
        ti.store_list("k_red", [x for r in K_RED for x in r])
        print("\nGuardado en variable 'k_red' (valores reales)")

    except Exception as e:
        print("Error:", e)

# Ejecutar
ensamblaje_final_completo()




    
  </code></pre>
</section>
