<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Ejemplo de Código</title>
</head>
<body>
  <!-- Título -->
  <h1>Codigo Mecanismos Fortran</h1>

  <!-- Fragmento de código -->
  <pre><code>
	          program E2
      implicit none
!     --- Declaracion de Variables ---
      integer, parameter :: n = 3
      real :: q(n), dp(n,n), dq(n), p(n)
      real :: ya, xb, yb, error, suma
      integer :: i, j, l, iter

!     --- Valores iniciales ---
      ya = 44.0
      xb = 100.0
      yb = 60.0
      error = 100.0
      iter = 0

      write(*,*) '--- Iniciando Newton-Raphson ---'
!     Encabezados alineados
      write(*,*) '  Iter       Error          YA          XB         YB'

!     --- Bucle de Newton-Raphson ---
      do while(error > 0.001)

         iter = iter + 1

!        Limpiar matriz Jacobiana (Vital)
         dp = 0.0

!        --- 1. Definir Ecuaciones (P) ---
         p(1) = 40.0**2 + ya**2 - 60.0**2
         p(2) = (xb-40.0)**2 + (yb-ya)**2 - 100.0**2
         p(3) = (120.0-xb)**2 + (0.0-yb)**2 - 130.0**2

!        --- 2. Definir Jacobiana (dp) ---
         dp(1,1) = 2.0 * ya

         dp(2,1) = -2.0 * (yb - ya)
         dp(2,2) =  2.0 * (xb - 40.0)
         dp(2,3) =  2.0 * (yb - ya)

         dp(3,2) = -2.0 * (120.0 - xb)
         dp(3,3) =  2.0 * yb

!        --- 3. Preparar sistema J*dq = -P ---
         p = -p

         call gj(dp, p, n, dq)

!        --- 4. Calcular Norma del Error ---
         suma = 0.0
         do i = 1, n
            suma = suma + dq(i)**2
         end do
         error = sqrt(suma)

!        --- 5. Actualizar variables ---
         ya = ya + dq(1)
         xb = xb + dq(2)
         yb = yb + dq(3)

!        --- Impresion de resultados ---
!        I6: Entero (Iter), F14.6: Error, 3F12.4: Variables
         write(*,'(I6, F14.6, 3F12.4)') iter, error, ya, xb, yb

      end do

      write(*,*) '--- Convergencia Lograda ---'
      write(*,*) 'Resultados Finales:'
      write(*,*) 'YA =', ya
      write(*,*) 'XB =', xb
      write(*,*) 'YB =', yb

      pause
      end program E2


!     ---------------------------------------------------
!     SUBRUTINA: GAUSS-JORDAN CON PIVOTEO PARCIAL
!     ---------------------------------------------------
      subroutine gj(A, b, dim, sol)
      implicit none
      integer, intent(in) :: dim
      real, intent(in) :: A(dim,dim), b(dim)
      real, intent(out) :: sol(dim)

      real :: m_amp(dim, dim+1)
      real :: temp(dim+1)
      real :: pivote
      integer :: i, k, l, max_fila

!     Copiar a matriz aumentada
      m_amp(1:dim, 1:dim) = A
      m_amp(:, dim+1) = b

      do i = 1, dim

!        1. Pivoteo Parcial (Buscar mayor en columna)
         max_fila = i
         do k = i+1, dim
            if (abs(m_amp(k,i)) > abs(m_amp(max_fila,i))) then
               max_fila = k
            end if
         end do

!        Intercambiar filas si es necesario
         if (max_fila /= i) then
            temp = m_amp(i,:)
            m_amp(i,:) = m_amp(max_fila,:)
            m_amp(max_fila,:) = temp
         end if

!        2. Normalizar fila pivote
         pivote = m_amp(i,i)
         if (abs(pivote) < 1.0E-8) then
             write(*,*) 'Error: Matriz Singular en paso', i
             stop
         end if
         m_amp(i,:) = m_amp(i,:) / pivote

!        3. Hacer ceros en el resto de la columna
         do l = 1, dim
            if (l /= i) then
             m_amp(l,:) = m_amp(l,:) - (m_amp(i,:) * m_amp(l,i))
            end if
         end do
      end do

!     Extraer solucion
      sol = m_amp(:, dim+1)

      end subroutine gj
  </code></pre>
</body>
</html>
